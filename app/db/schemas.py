# schemas.py
from pydantic import BaseModel
from typing import Optional

# Define a schema for creating a product
class ProductCreate(BaseModel):
    name: str
    description: str
    price: float
    image: str

# Define a schema for updating a product
class ProductUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    price: Optional[float] = None
    image: Optional[str] = None

# Define a schema for reading a product
class Product(BaseModel):
    key: str
    name: str
    description: str
    price: float
    image: str

# Define a schema for creating a user
class UserCreate(BaseModel):
    username: str
    email: str
    hashed_password: str
    is_active: bool = True
    is_admin: bool = False

# Define a schema for updating a user
class UserUpdate(BaseModel):
    username: Optional[str] = None
    email: Optional[str] = None
    hashed_password: Optional[str] = None
    is_active: Optional[bool] = None
    is_admin: Optional[bool] = None

# Define a schema for reading a user
class User(BaseModel):
    key: str
    username: str
    email: str
    hashed_password: str
    is_active: bool
    is_admin: bool

# Define a schema for creating a cart item
class CartItemCreate(BaseModel):
    user_key: str
    product_key: str
    quantity: int

# Define a schema for updating a cart item
class CartItemUpdate(BaseModel):
    user_key: Optional[str] = None
    product_key: Optional[str] = None
    quantity: Optional[int] = None

# Define a schema for reading a cart item
class CartItem(BaseModel):
    key: str
    user_key: str
    product_key: str
    quantity: int

# Define a schema for creating an order (not used directly, but as a nested schema)
class OrderCreate(BaseModel):
    user_key: str
    order_id: str # generated by Stripe or other payment service 
    items: list # list of CartItemCreate instances 
    total: float # calculated from the items and their prices 
    status: str # one of "pending", "paid", "shipped", "delivered", "cancelled"

# Define a schema for updating an order (not used directly, but as a nested schema)
class OrderUpdate(BaseModel):
    user_key: Optional[str] = None 
    order_id: Optional[str] = None 
    items: Optional[list] = None # list of CartItemUpdate instances 
    total: Optional[float] = None 
    status: Optional[str] = None # one of "pending", "paid", "shipped", "delivered", "cancelled"

# Define a schema for reading an order (not used directly, but as a nested schema)
class Order(BaseModel):
     key :str 
     user_key :str 
     order_id :str 
     items :list # list of CartItem instances 
     total :float 
     status :str # one of "pending", "paid", "shipped", "delivered", "cancelled"

# Define a schema for reading a token
class Token(BaseModel):
    access_token: str
    token_type: str